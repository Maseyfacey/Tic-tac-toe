import random

class TicTacToe:
    def __init__(self):
        self.reset_game()

    def reset_game(self):
        self.board = {}
        self.current_turn = 'X'
        print("The game has been reset.")

    def print_board(self):
        if not self.board:
            print("The board is empty.")
            return
        min_x = min(pos[0] for pos in self.board.keys())
        max_x = max(pos[0] for pos in self.board.keys())
        min_y = min(pos[1] for pos in self.board.keys())
        max_y = max(pos[1] for pos in self.board.keys())

        for y in range(min_y, max_y + 1):
            row = ""
            for x in range(min_x, max_x + 1):
                row += self.board.get((x, y), ".") + " "
            print(row)
    
    def make_move(self, x, y):
        if (x, y) in self.board:
            print("This position is already taken. Try another one.")
            return False
        self.board[(x, y)] = self.current_turn
        self.current_turn = 'O' if self.current_turn == 'X' else 'X'
        return True
    
    def ai_move(self):
        best_score = float('-inf')
        best_move = None
        for move in [(x, y) for x in range(-10, 11) for y in range(-10, 11) if (x, y) not in self.board]:
            self.board[move] = self.current_turn
            score = self.minimax(0, False)
            self.board.pop(move)
            if score > best_score:
                best_score = score
                best_move = move
        self.board[best_move] = self.current_turn
        self.current_turn = 'O' if self.current_turn == 'X' else 'X'

    def minimax(self, depth, is_maximizing):
        winner = self.check_winner()
        if winner == 'X':
            return -1
        elif winner == 'O':
            return 1
        elif len(self.board) == 400:  # Board is full
            return 0

        if is_maximizing:
            best_score = float('-inf')
            for move in [(x, y) for x in range(-10, 11) for y in range(-10, 11) if (x, y) not in self.board]:
                self.board[move] = 'O'
                score = self.minimax(depth + 1, False)
                self.board.pop(move)
                best_score = max(score, best_score)
            return best_score
        else:
            best_score = float('-inf')
            for move in [(x, y) for x in range(-10, 11) for y in range(-10, 11) if (x, y) not in self.board]:
                self.board[move] = 'X'
                score = self.minimax(depth + 1, True)
                self.board.pop(move)
                best_score = min(score, best_score)
            return best_score

    def check_winner(self):
        directions = [(1, 0), (0, 1), (1, 1), (1, -1)]
        for (x, y), player in self.board.items():
            for dx, dy in directions:
                count = 1
                for i in range(1, 5):
                    if self.board.get((x + i * dx, y + i * dy)) == player:
                        count += 1
                    else:
                        break
                if count == 5:
                    return player
        return None

game = TicTacToe()
while True:
    game.print_board()
    if game.current_turn == 'X':
        x = int(input("Enter the x coordinate: "))
        y = int(input("Enter the y coordinate: "))
        if not game.make_move(x, y):
            continue
    else:
        game.ai_move()

    winner = game.check_winner()
    if winner:
        game.print_board()
        print(f"Player {winner} wins!")
        if input("Play again? (y/n): ").lower() == 'y':
            game.reset_game()
        else:
            break
